{"version":3,"sources":["webpack://PSPDFKit/./src/utils/search.js","webpack://PSPDFKit/./src/lib/requests/RequestQueue.js","webpack://PSPDFKit/./src/lib/ServerBackend/authentication.js","webpack://PSPDFKit/./src/lib/requests/types/DOMElementImageRequest.js","webpack://PSPDFKit/./src/lib/ServerBackend/ServerBackendState.js","webpack://PSPDFKit/./src/lib/requests/types/XHRImageRequest.js","webpack://PSPDFKit/./src/lib/ServerBackend/ServerBackend.js","webpack://PSPDFKit/./src/utils/load.js"],"names":["__webpack_require__","d","__webpack_exports__","parseJsonSearchResults","_lib_serializers_rect__WEBPACK_IMPORTED_MODULE_0__","immutable__WEBPACK_IMPORTED_MODULE_1__","_pspdfkit_shared__WEBPACK_IMPORTED_MODULE_2__","_models_search_SearchResult__WEBPACK_IMPORTED_MODULE_3__","json","invariant","Array","isArray","List","map","rawResult","pageIndex","previewText","rangeInPreview","rectsOnPage","isAnnotation","SearchResult","locationInPreview","lengthInPreview","jsonRect","JSONToRect","filter","Boolean","functionThatReturnsTrue","RequestQueue","inflightRequestLimit","_babel_runtime_helpers_classCallCheck__WEBPACK_IMPORTED_MODULE_1___default","this","queue","OrderedMap","priorityQueue","inFlightRequests","Map","isDestroyed","request","_this","hasPriority","arguments","length","undefined","promise","Promise","cancel","resolve","reject","resolveFn","rejectFn","targetQueue","newQueue","set","next","setTimeout","_cancel","has","delete","response","promiseTuple","get","error","_this2","size","lastEntry","findLastEntry","_lastEntry","_babel_runtime_helpers_slicedToArray__WEBPACK_IMPORTED_MODULE_0___default","then","_requestFinished","catch","_requestFailed","findEntry","_lastEntry3","authenticate","_x","_x2","_x3","_authenticate","apply","_callee","documentURL","authPayload","password","res","regenerator_default","a","wrap","_context","prev","fetch","concat","method","headers","Content-Type","PSPDFKit-Platform","PSPDFKit-Version","PSPDFKIT_DEFINES","body","JSON","stringify","jwt","origin","window","location","href","credentials","sent","ok","abrupt","text","message","PSPDFKitError","statusText","stop","DOMElementImageRequest","url","token","classCallCheck_default","identifier","placeholderImage","Image","onload","ImageHandle","onerror","src","ServerBackendState","Record","serverUrl","documentId","backendPermissions","imageToken","syncProvider","instantProvider","features","isFormsEnabled","minSearchQueryLength","documentHandle","isDocumentHandleOutdated","GENERIC_RENDER_ERROR","XHRImageRequest","payload","httpRequest","XMLHttpRequest","open","setRequestHeader","webp","responseType","onreadystatechange","readyState","type","fileReader","FileReader","event","parse","target","result","attachments_not_found","attachmentsNotFound","readAsText","requestIsSuccess","status","blob","objectUrl","URL","createObjectURL","image","imageHandle","revokeObjectURL","bind","send","ServerBackend","configuration","_window","defineProperty_default","annotation","attachment","width","height","detached","resolvePromise","rejectPromise","renderAnnotationURL","_state","requestQueueId","generateUlid","id","annotationJSON","data","serializeAnnotation","isCanceled","requestPromises","requestAnnotation","includeAttachmentIds","formData","FormData","append","imageAttachmentId","imageRequestPromise","imageRequest","_requestQueue","enqueue","push","forEach","cancelRequests","getBaseUrl","document","substr","protocol","host","typeof_default","JWT_INVALID","indexOf","userContent","split","atob","e","document_id","validateJWT","instant","MAX_RESOURCE_REQUESTS_IN_QUEUE_SERVER","disableForms","permissions","hasPassword","layerHandle","allowedTileScales","_password","includes","withMutations","state","BackendPermissions","readOnly","downloadingAllowed","provider","destroy","_initProvider","setDocumentHandleConflictCallback","handleDocumentHandleConflict","jsActionChanges","InstantProvider","auth_token","RESTProvider","_fetch","totalPages","pageCount","v","annotations","fields","Error","pageTextRequestURL","jsonRequestPromise","_getJSONRequestHandler","jsonToTextLines","rects","rectsParam","encodeURIComponent","rectToJSON","toArray","JSONRequest","pageSize","tileRect","renderForPrinting","contentState","_this3","imageTileURL","left","top","getDocumentHandle","hasRetried","requestTile","isModifiableAnnotation","toJS","content","formFieldValues","serializeFormFieldValue","formFields","serializeFormField","attachments","_getImageRequestHandler","tile","_requestRenderAnnotation","attachmentId","_context5","t1","engine","engineVersion","searchTerm","startPageIndex","limitPages","params","flatten","String","r","arrayBuffer","revoke","_this4","isRevoked","exportPDF","Blob","outline","documentOutlineFromJSON","operations","createOperationsPayload","_context8","t0","reloadDocument","load","_context9","_context10","cancelAll","_clients","disconnect","options","objectSpread_default","X-PSPDFKit-Token","reason","_callee13","operationsDocuments","blobWeakMap","processedOperations","_context13","WeakMap","all","_ref4","asyncToGenerator_default","mark","_callee12","operation","index","formIndex","_context12","File","toString","_x11","_x12"],"mappings":"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","file":"pspdfkit-lib/chunk-server-29cf50396508fd29.js","sourcesContent":["/* @flow */\n\nimport { JSONToRect } from '../lib/serializers/rect'\nimport { List } from 'immutable'\nimport { invariant } from '@pspdfkit/shared'\nimport SearchResult from '../models/search/SearchResult'\n\nexport function parseJsonSearchResults(json: Array<Object>): List<SearchResult> {\n  invariant(Array.isArray(json), 'Wrong `json` field')\n  return List(\n    json\n      .map(rawResult => {\n        invariant(typeof rawResult.pageIndex === 'number', 'Wrong `pageIndex` field')\n        invariant(typeof rawResult.previewText === 'string', 'Wrong `previewText` field')\n        invariant(Array.isArray(rawResult.rangeInPreview), 'Wrong `rangeInPreview` field')\n        invariant(Array.isArray(rawResult.rectsOnPage), 'Wrong `rectsOnPage` field')\n\n        // We ignore results that are found in annotations for now since we for\n        // example don't have notes now, which results in results popping up where\n        // no text is.\n        if (rawResult.isAnnotation) {\n          return\n        }\n\n        return new SearchResult({\n          pageIndex: rawResult.pageIndex,\n          previewText: rawResult.previewText,\n          locationInPreview: rawResult.rangeInPreview[0],\n          lengthInPreview: rawResult.rangeInPreview[1],\n          rectsOnPage: List(rawResult.rectsOnPage).map(jsonRect => JSONToRect(jsonRect)),\n        })\n      })\n      .filter(Boolean),\n  )\n}\n","/* @flow */\n\nimport { OrderedMap, Map, set } from 'immutable'\nimport { Request } from './types/Request'\nimport { invariant } from '@pspdfkit/shared'\n\ntype PromiseTuple = {\n  promise: Promise<any>,\n  resolve: any => mixed,\n  reject: any => mixed,\n}\n\nfunction functionThatReturnsTrue() {\n  return true\n}\n\nexport default class RequestQueue {\n  queue: OrderedMap<Request, PromiseTuple>\n  priorityQueue: OrderedMap<Request, PromiseTuple>\n  inFlightRequests: Map<Request, PromiseTuple>\n  inflightRequestLimit: number\n  isDestroyed: boolean\n\n  constructor(inflightRequestLimit: number) {\n    this.queue = OrderedMap()\n    this.priorityQueue = OrderedMap()\n    this.inFlightRequests = Map()\n    this.inflightRequestLimit = inflightRequestLimit\n    this.isDestroyed = false\n  }\n\n  /**\n   * Enqueues the given `request` and returns a promise, which resolves with the\n   * response from the request. It's important to save the returned promise and\n   * not call `.then` on it, otherwise you would get a new promise back, since\n   * Promises are immutable.\n   *\n   * Enqueuing a request doesn't mean that your given request got resolved, but\n   * you're listening now on the given response of this request.\n   *\n   * @example\n   * const { promise, cancel } = requestQueue.enqueue(request)\n   * promise.then(function (response) {\n   *  // you code goes here\n   * })\n   */\n  enqueue(\n    request: Request,\n    hasPriority: boolean = false,\n  ): { promise: Promise<any>, cancel: () => void } {\n    if (this.isDestroyed) {\n      return { promise: new Promise(() => {}), cancel: () => {} }\n    }\n\n    const cancel = () => {\n      return this._cancel(request)\n    }\n\n    // We need the any cast here as flow does not know that the resolve and\n    // reject functions are initialized synchronously.\n    let resolve: any = null\n    let reject: any = null\n    const promise = new Promise((resolveFn, rejectFn) => {\n      resolve = resolveFn\n      reject = rejectFn\n    })\n\n    const targetQueue: OrderedMap<Request, PromiseTuple> = hasPriority\n      ? this.priorityQueue\n      : this.queue\n\n    const newQueue = set(\n      targetQueue,\n      request,\n      ({\n        promise,\n        resolve,\n        reject,\n      }: PromiseTuple),\n    )\n\n    if (hasPriority) {\n      this.priorityQueue = newQueue\n    } else {\n      this.queue = newQueue\n    }\n\n    if (hasPriority) {\n      // We can resolve the new requests immediately\n      this.next()\n    } else {\n      // Resolve the new request asynchronously so that other requests with\n      // `hasPriority: true` fires first.\n      setTimeout(() => this.next(), 35)\n    }\n\n    return { promise, cancel }\n  }\n\n  _cancel(request: Request): void {\n    if (this.queue.has(request)) {\n      this.queue = this.queue.delete(request)\n    }\n\n    if (this.priorityQueue.has(request)) {\n      this.priorityQueue = this.priorityQueue.delete(request)\n    }\n\n    if (this.inFlightRequests.has(request)) {\n      this.inFlightRequests = this.inFlightRequests.delete(request)\n    }\n  }\n\n  /**\n   * Cancels all the requests and removes all the promises\n   */\n  cancelAll(): void {\n    this.queue = OrderedMap()\n    this.priorityQueue = OrderedMap()\n    this.inFlightRequests = Map()\n  }\n\n  /**\n   * Resolves and then removes the queued request, identified by the given\n   * `url`. Also starts the next request in the queue\n   */\n  _requestFinished(request: Request, response: any): void {\n    if (this.isDestroyed) {\n      return\n    }\n\n    const promiseTuple = this.inFlightRequests.get(request)\n\n    if (promiseTuple) {\n      promiseTuple.resolve(response)\n      this.inFlightRequests = this.inFlightRequests.delete(request)\n    }\n\n    this.next()\n  }\n\n  /**\n   * Rejects promise with given error and queues next request\n   */\n  _requestFailed(request: Request, error: Error) {\n    if (this.isDestroyed) {\n      return\n    }\n\n    const promiseTuple = this.inFlightRequests.get(request)\n\n    if (promiseTuple) {\n      promiseTuple.reject(error)\n      this.inFlightRequests = this.inFlightRequests.delete(request)\n    }\n\n    this.next()\n  }\n\n  /**\n   * Queues next request\n   */\n  next() {\n    if (this.isDestroyed) {\n      return\n    }\n\n    if (this.inFlightRequests.size >= this.inflightRequestLimit) {\n      return\n    }\n\n    if (this.priorityQueue.size >= 1) {\n      // Use LIFO, because we want to see the overviews that get loaded last\n      // first (because often these are the tiles that came into the viewport).\n      const lastEntry: void | [Request, PromiseTuple] = this.priorityQueue.findLastEntry(\n        functionThatReturnsTrue,\n      )\n\n      invariant(lastEntry)\n      const [request, promiseTuple] = lastEntry\n\n      this.priorityQueue = this.priorityQueue.delete(request)\n      this.inFlightRequests = this.inFlightRequests.set(request, promiseTuple)\n      request\n        .request()\n        .then(response => this._requestFinished(request, response))\n        .catch(error => this._requestFailed(request, error))\n\n      return\n    }\n\n    if (this.queue.size >= 1) {\n      const lastEntry: void | [Request, PromiseTuple] = this.queue.findEntry(\n        functionThatReturnsTrue,\n      )\n\n      invariant(lastEntry)\n      const [request, promiseTuple] = lastEntry\n\n      this.queue = this.queue.delete(request)\n      this.inFlightRequests = this.inFlightRequests.set(request, promiseTuple)\n\n      request\n        .request()\n        .then(response => this._requestFinished(request, response))\n        .catch(error => this._requestFailed(request, error))\n\n      return\n    }\n  }\n\n  destroy() {\n    this.isDestroyed = true\n  }\n}\n","// @flow\n\nimport { PSPDFKitError } from '@pspdfkit/shared'\n\nexport type AuthResponse = {|\n  imageToken: string,\n  token: string,\n  permissions: Array<string>,\n  features: Array<string>,\n  hasPassword: boolean,\n  minSearchQueryLength: number,\n  layerHandle: string,\n  allowedTileScales: 'all' | Array<number>,\n|}\n\n/**\n * Calls the `/auth` endpoint and generates the tokens.\n */\nexport async function authenticate(\n  documentURL: string,\n  authPayload: {| jwt: string |},\n  password: ?string,\n): Promise<AuthResponse> {\n  const res = await fetch(`${documentURL}/auth`, {\n    method: 'POST',\n    headers: {\n      'Content-Type': 'application/json',\n      'PSPDFKit-Platform': 'web',\n      'PSPDFKit-Version': `protocol=${PSPDFKIT_DEFINES.SERVER_PROTOCOL}, client=${\n        PSPDFKIT_DEFINES.VERSION\n      }, client-git=${PSPDFKIT_DEFINES.REVISION}`,\n    },\n    body: JSON.stringify({\n      jwt: authPayload.jwt,\n      // IE11 does not send `Origin` headers for some requests, since it has a different\n      // understanding of the origin spec. To still be able to verify the origin in the IE11 case,\n      // we add that information as payload manually.\n      // There were some problems with `window.location.origin` in IE11 on Win10 [1], that's why\n      // we use `window.location.href` instead.\n      // [1]: https://goo.gl/5D5mNX\n      origin: window.location.href,\n      password: password,\n    }),\n    credentials: 'include',\n  })\n\n  if (res.ok) {\n    return res.json()\n  } else {\n    return res.text().then(message => {\n      if (message === 'INVALID_PASSWORD') {\n        throw new PSPDFKitError(message)\n      } else {\n        throw new PSPDFKitError(\n          `An error ocurred while connecting to PSPDFKit Server: ${message || res.statusText}`,\n        )\n      }\n    })\n  }\n}\n","/**\n * The DOMElementImageRequest will use an HTMLImageElement to preload the image (using a simple\n * `new Image()`). This loading request will add cookies on Chrome, Firefox and Edge, which allows\n * us to properly authenticate the request. We have no ability to add a custom payload that is not\n * set as a cross side cookie (since the only option would be to add a query parameter and that\n * would break caching).\n *\n * A problem with this approach is that when a loading error occurs, we have no idea what went\n * wrong. We only know that an error occurred (the `onerror` handler is called without arguments).\n *\n * @flow\n */\n\nimport { Request } from './Request'\nimport ImageHandle from '../../handles/ImageHandle'\n\nexport default class DOMElementImageRequest implements Request {\n  identifier: string\n  token: string\n  url: string\n\n  constructor(url: string, token: string) {\n    this.identifier = this.url = url\n    this.token = token\n  }\n\n  request(): Promise<ImageHandle> {\n    return new Promise((resolve, reject) => {\n      let placeholderImage = new Image()\n      placeholderImage.onload = () => resolve(new ImageHandle(placeholderImage, () => {}))\n      placeholderImage.onerror = () => reject()\n      placeholderImage.src = this.url\n    })\n  }\n}\n","/* @flow */\n\nimport { List } from 'immutable'\nimport { Record } from 'immutable'\nimport BackendPermissions from '../../models/BackendPermissions'\n\nexport default class ServerBackendState extends (Record({\n  authPayload: null,\n  serverUrl: null,\n  documentId: null,\n  backendPermissions: null,\n  documentURL: null,\n  imageToken: null,\n  syncProvider: null,\n  instantProvider: null,\n  token: null,\n  features: List(),\n  isFormsEnabled: true,\n  minSearchQueryLength: 1,\n  documentHandle: null,\n  isDocumentHandleOutdated: false,\n}): any) {\n  /**\n   * The auth payload used to create the PSPDFKit for Web instance. This is most likely an object\n   * with a key `jwt` that contains the `jwt`.\n   * We also use a special internal authentication token for the PSPDFKit Server dashboard, this\n   * also creates an object here with the key `jwt` but the value is no valid JWT!\n   */\n  authPayload: {| jwt: string |}\n\n  /**\n   * URL to the PSPDFKit Server, e.g: `https://pspdfkit.example.com/`\n   */\n  serverUrl: string\n\n  /**\n   * The identifier of the document for PSPDFKit Server\n   */\n  documentId: string\n\n  /**\n   * Defines if the user is allowed to edit annotations or download the document\n   */\n  backendPermissions: BackendPermissions\n\n  /**\n   * URL to the document, e.g.: `https://pspdfkit.example.com/d/foobar`\n   */\n  documentURL: string\n\n  /**\n   * This token is used to retrieve images from the Server.\n   */\n  imageToken: string\n\n  /**\n   * The write token generated by PSPDFKit Server. This is used to authenticate all non image\n   * loading requests.\n   */\n  token: string\n\n  /**\n   * Used to define which AnnotationProvider is used to communicate with the Server.\n   */\n  syncProvider: boolean\n\n  /**\n   * Used to define which AnnotationProvider is used to communicate with the Server.\n   */\n  instantProvider: boolean\n\n  /**\n   * PSPDFKit license features, used to detect which features can be used.\n   */\n  features: List<string>\n\n  /**\n   * Scans the Configuration and the returned features to see if forms shall be implemented. This is\n   * necessary since we initialize the RESTProvider before we can process this information in\n   * other parts of the app.\n   * @FIXME: Find a way to get the actual licenses when initializing RESTProvider so that we don't\n   * have to maintain a separate implementation of form related feature tests.\n   */\n  isFormsEnabled: boolean\n\n  /**\n   * ID string corresponding to the current document. This field is updated when operations\n   * are applied on the document with the new document SHA256 hash.\n   */\n  documentHandle: string\n\n  /**\n   * Set when the document has been modified by an external client, thereby modifying the document handle.\n   * When set, the backend should authenticate again and load the modified document with the new `documentHandle`.\n   */\n  isDocumentHandleOutdated: boolean\n}\n","/**\n * The XHRImageRequest will use an XHR request with a custom header tag to load the image. It will\n * load the image using the blob API and return an objectUrl that can be used to display the image.\n *\n * The main benefit of this approach is that we can control http request headers that are sent when\n * loading the image. This makes it possible for this approach to work in Safari, where we otherwise\n * have no ability to add a custom payload to the image loading request (since cookies will not be\n * send there).\n *\n * Be aware that this method generates an objectUrl from the blob data every time it loads an image.\n * This is an problem in the latest version of Chrome, where garbage collection of object urls does\n * not properly work.\n * https://bugs.chromium.org/p/chromium/issues/detail?id=570268#c25\n *\n * This method is also not suitable for Edge, where currently no XHR requests are cached at all.\n *\n * @TODO use `fetch()` instead of a plain `XMLHttpRequest()` once `fetch` has support for aborting\n *\n * @flow\n */\nimport { Request } from './Request'\nimport { requestIsSuccess } from '../../../utils/http'\nimport { webp } from '../../../utils/features'\nimport { PSPDFKitError } from '@pspdfkit/shared'\nimport ImageHandle from '../../handles/ImageHandle'\n\nconst GENERIC_RENDER_ERROR = 'The image can not be rendered because of an unknown error.'\n\nexport default class XHRImageRequest implements Request {\n  identifier: string\n  token: string\n  url: string\n  payload: any\n\n  constructor(identifier: string, url: string, token: string, payload?: any) {\n    this.identifier = identifier\n    this.url = url\n    this.token = token\n    this.payload = payload\n  }\n\n  request(): Promise<ImageHandle | { attachmentsNotFound: Array<string> }> {\n    return new Promise((resolve, reject) => {\n      const httpRequest = new XMLHttpRequest()\n      httpRequest.open(this.payload ? 'POST' : 'GET', this.url, true)\n      httpRequest.setRequestHeader('X-PSPDFKit-Image-Token', this.token)\n      if (webp) {\n        httpRequest.setRequestHeader('Accept', 'image/webp,*/*')\n      }\n      httpRequest.responseType = 'blob'\n\n      // We need to use the spec conform `onreadystatechange` since `onload` and `onerror` behaves\n      // differently in our test environment\n      // @TODO inspect what's causing the context of the arrow function to change\n      httpRequest.onreadystatechange = (() => {\n        // request finished and response is ready\n        if (httpRequest.readyState !== 4) {\n          return\n        }\n\n        if (httpRequest.response.type === 'application/json') {\n          // We have to read the blob here using a FileReader since we configure the http request as\n          // a blob one.\n          const fileReader = new FileReader()\n          fileReader.onload = event => {\n            const response = JSON.parse(event.target.result)\n\n            if (response.attachments_not_found) {\n              resolve({ attachmentsNotFound: response.attachments_not_found })\n            } else if (response.error) {\n              reject(\n                new PSPDFKitError(\n                  `The server could not render the requested image (${response.error})`,\n                ),\n              )\n            } else {\n              reject(new PSPDFKitError(GENERIC_RENDER_ERROR))\n            }\n          }\n          fileReader.onerror = () => reject(new PSPDFKitError(GENERIC_RENDER_ERROR))\n          fileReader.readAsText(httpRequest.response)\n\n          return\n        }\n\n        if (!requestIsSuccess(httpRequest.status)) {\n          reject(new PSPDFKitError(GENERIC_RENDER_ERROR))\n          return\n        }\n\n        const blob = httpRequest.response\n        const objectUrl = URL.createObjectURL(blob)\n\n        const image = new Image()\n        image.onload = () => {\n          const imageHandle = new ImageHandle(image, () => URL.revokeObjectURL(objectUrl))\n          resolve(imageHandle)\n        }\n        image.onerror = () => reject(new PSPDFKitError(GENERIC_RENDER_ERROR))\n        image.src = objectUrl\n      }).bind(this)\n\n      httpRequest.send(this.payload)\n    })\n  }\n}\n","// @flow\n\nimport { authenticate } from './authentication'\nimport { Backend } from '../Backend'\nimport { BackendPermissions, Size, Rect } from '../../models'\nimport { engine, engineVersion } from '../../utils/browser'\nimport { fromJSON as documentOutlineFromJSON } from '../serializers/OutlineElementSerializer'\nimport { getBaseUrl } from '../../utils/environment'\nimport { isModifiableAnnotation } from '../../utils/annotation'\nimport { jsonToTextLines } from '../../utils/textLines'\nimport { List } from 'immutable'\nimport { Map } from 'immutable'\nimport { MAX_RESOURCE_REQUESTS_IN_QUEUE_SERVER } from '../../constants/config'\nimport { parseJsonSearchResults } from '../../utils/search'\nimport { PSPDFKitError, invariant } from '@pspdfkit/shared'\nimport { rectToJSON } from '../serializers/rect'\nimport {\n  serializeAnnotation,\n  serializeFormFieldValue,\n  serializeFormField,\n} from '../serializers/utils'\nimport { validateJWT } from '../../utils/load'\nimport DOMElementImageRequest from '../requests/types/DOMElementImageRequest'\nimport ImageHandle from '../handles/ImageHandle'\nimport JSONRequest from '../requests/types/JSONRequest'\nimport RequestQueue from '../requests/RequestQueue'\nimport ServerBackendState from './ServerBackendState'\nimport type { Annotation, Attachment } from '../../models'\nimport type { AnnotationProvider } from '../AnnotationProvider'\nimport type {\n  DocumentResponse,\n  TextResponse,\n  FormResponse,\n  BackendType,\n  LoadResponse,\n} from '../Backend'\nimport type { FormFieldValue, FormField } from '../../models'\nimport type { ActionChange } from '../../models/actions/Action'\nimport type { DocumentOperationJSON } from '../../models/DocumentOperation'\nimport type { FormFieldValueProvider } from '../FormFieldValueProvider'\nimport type { InstantJSON } from '../../lib/InstantJSON'\nimport type { ServerConfiguration } from '../../Configuration'\nimport type OutlineElement from '../../models/OutlineElement'\nimport type SearchResult from '../../models/search/SearchResult'\nimport XHRImageRequest from '../requests/types/XHRImageRequest'\nimport generateUlid from '../../utils/ulid'\n\nexport default class ServerBackend implements Backend {\n  // $FlowIssue remove when enabling BookmarkProvider for ServerBackend\n  provider: AnnotationProvider & FormFieldValueProvider & FormFieldProvider\n  _state: ServerBackendState\n  _requestQueue: RequestQueue\n  _password: ?string = null\n\n  type: BackendType = 'SERVER'\n\n  constructor(configuration: ServerConfiguration, _window?: window = window) {\n    let serverUrl = configuration.serverUrl || getBaseUrl(_window.document)\n\n    // serverUrl must have a slash at the end\n    if (serverUrl.substr(-1) !== '/') {\n      throw new PSPDFKitError(\n        '`serverUrl` must have a slash at the end (e.g. `https://pspdfkit.example.com/`).',\n      )\n    }\n\n    // Verify that the base URL is different from the current browser's location. If it's the same,\n    // we assume that we haven't loaded PSPDFKit for Web from the Server origin and bail out. If\n    // the `serverUrl` is explicitly set in the configuration, we will always use it\n    if (!configuration.serverUrl) {\n      // There were some problems with `window.location.origin` in IE11 on Win10 [1], that's why\n      // we use `window.location.host` instead.\n      // [1]: https://goo.gl/5D5mNX\n      const browserOrigin = `${_window.location.protocol}//${_window.location.host}/`\n      if (serverUrl === browserOrigin) {\n        throw new PSPDFKitError(\n          `PSPDFKit automatically infers the URL of PSPDFKit Server from the current \\`<script>\\` tag.\nIn the current case, this URL is set to the same as the current browser's location.\nThis can happen when you bundle pspdfkit.js with your custom JavaScript for example.\n\nTo make sure everything works as expected, please set the \\`serverUrl\\` to the URL of PSPDFKit Server:\n\nPSPDFKit.load({\n  serverUrl: \"https://pspdfkit-server.example.com/\",\n  ...,\n});`,\n        )\n      }\n    }\n\n    // Validate document ID\n    if (typeof configuration.documentId !== 'string') {\n      throw new PSPDFKitError('`documentId` must be of type string.')\n    }\n\n    // Validate authPayload\n    if (\n      !(\n        typeof configuration.authPayload === 'object' &&\n        typeof configuration.authPayload.jwt === 'string'\n      )\n    ) {\n      throw new PSPDFKitError(\n        \"authPayload must be an object that contains the `jwt`. For example: `authPayload: { jwt: 'xxx.xxx.xxx'}`\",\n      )\n    }\n\n    validateJWT(configuration.authPayload.jwt)\n\n    // Validate instant\n    if (typeof configuration.instant !== 'boolean') {\n      throw new PSPDFKitError(`\\`instant\\` flag must either be set to \\`true\\` or \\`false\\`.\n\nFor more information about PSPDFKit Instant please visit:\nhttps://pspdfkit.com/guides/web/current/instant/overview/`)\n    }\n\n    this._requestQueue = new RequestQueue(MAX_RESOURCE_REQUESTS_IN_QUEUE_SERVER)\n    this._state = new ServerBackendState({\n      serverUrl,\n      documentId: configuration.documentId,\n      instantProvider: Boolean(configuration.instant),\n      documentURL: `${serverUrl}i/d/${configuration.documentId}`,\n      authPayload: configuration.authPayload,\n      isFormsEnabled: !configuration.disableForms,\n    })\n  }\n\n  isUsingInstantProvider(): boolean {\n    return this._state.instantProvider\n  }\n\n  async load(password: ?string) {\n    const {\n      imageToken,\n      token,\n      permissions,\n      features,\n      hasPassword,\n      minSearchQueryLength,\n      layerHandle,\n      allowedTileScales,\n    } = await authenticate(\n      `${this._state.serverUrl}i/d/${this._state.documentId}`,\n      this._state.authPayload,\n      password,\n    )\n\n    // Keep for reloading after applying operations\n    this._password = password\n\n    // check for Instant feature enabled in license if configured for Instant\n    if (this._state.instantProvider && !features.includes('instant')) {\n      throw new PSPDFKitError(`Instant feature is not enabled on this server. Please set \\`instant\\` to \\`false\\`.\n\nFor more information about PSPDFKit Instant please visit:\nhttps://pspdfkit.com/guides/web/current/instant/overview/`)\n    }\n\n    this._state = this._state.withMutations(state => {\n      return state\n        .set('imageToken', imageToken)\n        .set('token', token)\n        .set('features', List(features))\n        .set(\n          'backendPermissions',\n          new BackendPermissions({\n            readOnly: permissions.indexOf('write') === -1,\n            downloadingAllowed: permissions.indexOf('download') >= 0,\n          }),\n        )\n        .set(\n          'documentURL',\n          `${this._state.serverUrl}i/d/${this._state.documentId}/h/${layerHandle}`,\n        )\n        .set('documentHandle', layerHandle)\n        .set('isDocumentHandleOutdated', false)\n    })\n\n    if (this.provider) {\n      this.provider.destroy()\n    }\n    this.provider = await this._initProvider()\n    this._state.instantProvider &&\n      this.provider.setDocumentHandleConflictCallback(this.handleDocumentHandleConflict)\n    return {\n      features: this._state.features,\n      hasPassword,\n      minSearchQueryLength,\n      allowedTileScales,\n      jsActionChanges: [],\n    }\n  }\n\n  async _initProvider(): Promise<AnnotationProvider & FormFieldValueProvider & FormFieldProvider> {\n    if (this._state.instantProvider) {\n      const documentURL = `${this._state.serverUrl}i/d/${this._state.documentId}/h/${\n        this._state.documentHandle\n      }`\n      const { InstantProvider } = await import(\n        /* webpackChunkName: \"server-instant\" */ '../InstantProvider/InstantProvider'\n      )\n      return new InstantProvider(\n        `${this._state.serverUrl}i/d/${this._state.documentId}`,\n        documentURL,\n        { auth_token: this._state.token },\n      )\n    } else {\n      const isFormsEnabled =\n        this._state.isFormsEnabled && this._state.features.includes('acro_forms')\n      const { RESTProvider } = await import(\n        /* webpackChunkName: \"server-rest\" */ '../RESTProvider/RESTProvider'\n      )\n      return new RESTProvider(\n        this._state.documentURL,\n        {\n          token: this._state.token,\n        },\n        {\n          isFormsEnabled,\n        },\n      )\n    }\n  }\n\n  destroy(): void {\n    this.provider && this.provider.destroy()\n    this._requestQueue && this._requestQueue.destroy()\n  }\n\n  documentInfo(): Promise<DocumentResponse> {\n    return this._fetch(`${this._state.documentURL}/document.json`)\n      .then(res => res.json())\n      .then(payload => {\n        // The server calls `totalPages` `pageCount`.\n        payload.data.totalPages = payload.data.pageCount\n        return payload.data\n      })\n  }\n\n  getFormJSON(): Promise<FormResponse> {\n    return this._fetch(`${this._state.documentURL}/form.json`).then(res => {\n      if (res.status === 403) {\n        return {\n          v: 1,\n          type: 'pspdfkit/form',\n          annotations: [],\n          fields: [],\n        }\n      } else {\n        return res.json().then(json => json.data)\n      }\n    })\n  }\n\n  async evalFormValuesActions() {\n    throw new Error('not implemented')\n  }\n\n  async evalScript() {\n    throw new Error('not implemented')\n  }\n\n  permissions(): Promise<BackendPermissions> {\n    return Promise.resolve(this._state.backendPermissions)\n  }\n\n  textForPageIndex(pageIndex: number): {| promise: Promise<TextResponse>, cancel: Function |} {\n    const pageTextRequestURL = `${this._state.documentURL}/page-${pageIndex}-text`\n    const jsonRequestPromise = new (this._getJSONRequestHandler())(\n      pageTextRequestURL,\n      this._state.token,\n    )\n    const request = this._requestQueue.enqueue(jsonRequestPromise, true)\n\n    const jsonRequestQueuePromise = request.promise.then(json => jsonToTextLines(json, pageIndex))\n\n    return {\n      promise: jsonRequestQueuePromise,\n      cancel: () => {\n        request.cancel()\n      },\n    }\n  }\n\n  getTextFromRects(pageIndex: number, rects: List<Rect>): Promise<string> {\n    const rectsParam = encodeURIComponent(JSON.stringify(rects.map(rectToJSON).toArray()))\n    return this._fetch(\n      `${this._state.documentURL}/page-${pageIndex}-highlighted?rects=${rectsParam}`,\n    )\n      .then(res => res.json())\n      .then(response => response.text)\n  }\n\n  _getJSONRequestHandler() {\n    return JSONRequest\n  }\n\n  renderTile(\n    pageIndex: number,\n    pageSize: Size,\n    tileRect: Rect,\n    renderForPrinting: boolean,\n    contentState: ?{\n      annotations: List<Annotation>,\n      formFieldValues: List<FormFieldValue>,\n      attachments: Map<string, Attachment>,\n      formFields: List<FormField>,\n    },\n  ): {| promise: Promise<ImageHandle>, cancel: Function |} {\n    if (this._state.isDocumentHandleOutdated) {\n      return { promise: new Promise(() => {}), cancel: () => {} }\n    }\n    const imageTileURL = `${this._state.documentURL}/page-${pageIndex}-dimensions-${\n      pageSize.width\n    }-${pageSize.height}-tile-${tileRect.left}-${tileRect.top}-${tileRect.width}-${\n      tileRect.height\n    }-${this.getDocumentHandle()}${renderForPrinting ? '-print' : ''}`\n    const hasPriority = pageSize.width === tileRect.width && pageSize.height === tileRect.height\n\n    let resolvePromise,\n      rejectPromise,\n      isCanceled = false,\n      hasRetried = false,\n      requestPromises = []\n\n    const promise = new Promise((resolve, reject) => {\n      resolvePromise = resolve\n      rejectPromise = reject\n    })\n\n    const requestTile = (includeAttachmentIds: Array<string> = []) => {\n      let imageRequestPromise\n      if (contentState) {\n        let formData = new FormData()\n        formData.append(\n          'data',\n          JSON.stringify({\n            annotations: contentState.annotations\n              .filter(isModifiableAnnotation)\n              .map(serializeAnnotation)\n              .toJS()\n              .map(content => ({ content })),\n            formFieldValues: contentState.formFieldValues.map(serializeFormFieldValue).toJS(),\n            formFields: contentState.formFields.map(serializeFormField).toJS(),\n          }),\n        )\n        if (includeAttachmentIds.length > 0) {\n          includeAttachmentIds.forEach(id => {\n            const attachment = (contentState: any).attachments.get(id)\n            invariant(attachment && attachment.data, 'Attachment data could not be found.')\n            formData.append(id, attachment.data)\n          })\n        }\n\n        imageRequestPromise = new XHRImageRequest(\n          imageTileURL,\n          imageTileURL,\n          this._state.imageToken,\n          formData,\n        )\n      } else {\n        imageRequestPromise = new (this._getImageRequestHandler())(\n          imageTileURL,\n          imageTileURL,\n          this._state.imageToken,\n        )\n      }\n\n      const imageRequest = this._requestQueue.enqueue(imageRequestPromise, hasPriority)\n\n      imageRequest.promise\n        .then(tile => {\n          if (isCanceled) {\n            return\n          }\n\n          if (tile.attachmentsNotFound && !hasRetried) {\n            hasRetried = true\n            requestTile(tile.attachmentsNotFound)\n            return\n          }\n          if (tile.attachmentsNotFound) {\n            rejectPromise(new PSPDFKitError('Attachment could not be found.'))\n            return\n          }\n\n          resolvePromise(tile)\n        })\n        .catch(error => {\n          if (isCanceled) {\n            return\n          }\n\n          rejectPromise(error)\n        })\n\n      requestPromises.push(imageRequest)\n    }\n\n    requestTile()\n\n    return {\n      promise,\n      cancel: () => {\n        isCanceled = true\n        requestPromises.forEach(request => request.cancel())\n      },\n    }\n  }\n\n  /**\n   * Common method for renderAnnotation and renderDetachedAnnotation.\n   */\n  _requestRenderAnnotation = (\n    annotation: Annotation,\n    attachment: ?Attachment,\n    width: number,\n    height: number,\n    detached?: boolean,\n  ) => {\n    const renderAnnotationURL = `${this._state.documentURL}/render_annotation`\n    const requestQueueId = `render-annotation-${detached ? generateUlid() : annotation.id}`\n    const annotationJSON = JSON.stringify({\n      data: serializeAnnotation(annotation),\n      width: width,\n      height: height,\n      detached: detached || undefined,\n    })\n\n    let resolvePromise,\n      rejectPromise,\n      isCanceled = false,\n      hasRetried = false,\n      requestPromises = []\n\n    const promise = new Promise((resolve, reject) => {\n      resolvePromise = resolve\n      rejectPromise = reject\n    })\n\n    const requestAnnotation = (includeAttachmentIds: Array<string> = []) => {\n      let formData = new FormData()\n      formData.append('render', annotationJSON)\n      if (\n        includeAttachmentIds.length > 0 &&\n        annotation.imageAttachmentId &&\n        attachment &&\n        attachment.data\n      ) {\n        formData.append(annotation.imageAttachmentId, attachment.data)\n      }\n\n      const imageRequestPromise = new XHRImageRequest(\n        requestQueueId,\n        renderAnnotationURL,\n        this._state.imageToken,\n        formData,\n      )\n\n      const imageRequest = this._requestQueue.enqueue(imageRequestPromise, false)\n      imageRequest.promise\n        .then(result => {\n          if (isCanceled) {\n            return\n          }\n\n          if (result.attachmentsNotFound && !hasRetried) {\n            requestAnnotation(result.attachmentsNotFound)\n            return\n          }\n\n          if (result.attachmentsNotFound) {\n            rejectPromise(new PSPDFKitError('Attachment could not be found.'))\n            return\n          }\n\n          resolvePromise(result)\n        })\n        .catch(error => {\n          if (isCanceled) {\n            return\n          }\n\n          rejectPromise(error)\n        })\n      requestPromises.push(imageRequest)\n    }\n\n    requestAnnotation()\n\n    return {\n      promise,\n      cancel: () => {\n        isCanceled = true\n        requestPromises.forEach(request => request.cancel())\n      },\n    }\n  }\n\n  renderAnnotation(\n    annotation: Annotation,\n    attachment: ?Attachment,\n    width: number,\n    height: number,\n  ): {| promise: Promise<ImageHandle>, cancel: Function |} {\n    return this._requestRenderAnnotation(annotation, attachment, width, height)\n  }\n\n  renderDetachedAnnotation(\n    annotation: Annotation,\n    attachment: ?Attachment,\n    width: number,\n    height: number,\n  ): {| promise: Promise<ImageHandle>, cancel: Function |} {\n    return this._requestRenderAnnotation(annotation, attachment, width, height, true)\n  }\n\n  async getAttachment(attachmentId: string): Promise<Blob> {\n    try {\n      const res = await this._fetch(`${this._state.documentURL}/attachments/${attachmentId}`)\n      switch (res.status) {\n        case 404:\n          throw new PSPDFKitError('Attachment not Found.')\n        case 200:\n          return await res.blob()\n        default:\n          throw new PSPDFKitError('Bad Request.')\n      }\n    } catch (error) {\n      throw new PSPDFKitError(`Could not fetch attachment from PSPDFKit Server. ${error}`)\n    }\n  }\n\n  /**\n   * Returns the proper ImageRequest used for this browser\n   *\n   * We always prefer XHR requests since those are the only requests where we can definitely control\n   * the headers that are being sent. However, older versions of Chrome (we first observed it\n   * working in Chrome 60) and all Firefox versions (observed in Firefox 54) have a memory leak\n   * associated with `revokeObjectURL`. For those cases, we fall back to DOM Element loading, this\n   * requires the cookies to be part of the `<img>` request that might be disabled in some\n   * environments (observed in some Chrome environments, see #1293)\n   */\n  _getImageRequestHandler(): Class<XHRImageRequest | DOMElementImageRequest> {\n    if ((engine === 'blink' && engineVersion < 60) || engine === 'gecko') {\n      return DOMElementImageRequest\n    } else {\n      return XHRImageRequest\n    }\n  }\n\n  async search(\n    searchTerm: string,\n    startPageIndex: number,\n    limitPages: number,\n  ): Promise<List<SearchResult>> {\n    const params = `q=${encodeURIComponent(searchTerm)}&start=${startPageIndex}&limit=${limitPages}`\n    const url = `${this._state.documentURL}/search?${params}`\n    const response = await new JSONRequest(url, this._state.token).request()\n    return parseJsonSearchResults(response.data)\n  }\n\n  exportPDF(flatten: boolean = false): Promise<ArrayBuffer> {\n    const url = `${this._state.documentURL}/pdf?token=${this._state.token}&flatten=${String(\n      flatten,\n    )}`\n\n    return fetch(url, {\n      method: 'GET',\n      credentials: 'include',\n    }).then(r => r.arrayBuffer())\n  }\n\n  exportXFDF(): Promise<string> {\n    return this._fetch(`${this._state.documentURL}/document.xfdf`).then(res => res.text())\n  }\n\n  exportInstantJSON(): Promise<InstantJSON> {\n    return this._fetch(`${this._state.documentURL}/instant.json`).then(res => res.json())\n  }\n\n  getPDFURL(): {| promise: Promise<string>, revoke: Function |} {\n    return {\n      promise: Promise.resolve(\n        `${this._state.documentURL}/pdf?token=${this._state.token}&flatten=true`,\n      ),\n      revoke: () => {},\n    }\n  }\n\n  generatePDFObjectURL(): {| promise: Promise<string>, revoke: Function |} {\n    let objectUrl,\n      isRevoked = false\n\n    const promise = new Promise(resolve => {\n      this.exportPDF().then(arrayBuffer => {\n        if (isRevoked) {\n          return\n        }\n        const blob = new Blob([arrayBuffer], { type: 'application/pdf' })\n        objectUrl = window.URL.createObjectURL(blob)\n        resolve(objectUrl)\n      })\n    })\n\n    return {\n      promise,\n      revoke: () => {\n        if (objectUrl) {\n          window.URL.revokeObjectURL(objectUrl)\n        }\n        isRevoked = true\n      },\n    }\n  }\n\n  async getDocumentOutline(): Promise<List<OutlineElement>> {\n    let data\n    try {\n      const json = await this._fetch(`${this._state.documentURL}/outline.json`).then(res =>\n        res.json(),\n      )\n      data = json.data\n    } catch (e) {\n      data = {}\n    }\n    const outline = Array.isArray(data.outline) ? data.outline : []\n    return List(outline.map(documentOutlineFromJSON))\n  }\n\n  onKeystrokeEvent(): Promise<Array<ActionChange>> {\n    throw new Error('not implemented')\n  }\n\n  async applyOperationsAndReload(operations: Array<DocumentOperationJSON>): Promise<LoadResponse> {\n    try {\n      const body = await createOperationsPayload(operations)\n      await this._fetch(`${this._state.documentURL}/apply-operations`, {\n        method: 'post',\n        body,\n        credentials: 'include',\n      })\n    } catch (e) {\n      throw new PSPDFKitError(`Applying operations failed: ${e}`)\n    }\n\n    return this.reloadDocument()\n  }\n\n  async reloadDocument(): Promise<LoadResponse> {\n    try {\n      return await this.load(this._password)\n    } catch (e) {\n      throw new PSPDFKitError(`Reloading the document failed: ${e}`)\n    }\n  }\n\n  async exportPDFWithOperations(operations: Array<DocumentOperationJSON>): Promise<ArrayBuffer> {\n    try {\n      const body = await createOperationsPayload(operations)\n      return this._fetch(`${this._state.documentURL}/pdf-with-operations`, {\n        method: 'post',\n        body,\n        credentials: 'include',\n      }).then(res => res.arrayBuffer())\n    } catch (e) {\n      throw new PSPDFKitError(`Exporting PDF with operations failed: ${e}`)\n    }\n  }\n\n  handleDocumentHandleConflict = () => {\n    this._state = this._state.set('isDocumentHandleOutdated', true)\n    this.cancelRequests()\n  }\n\n  getDocumentHandle() {\n    return this._state.documentHandle\n  }\n\n  // Cancels all current requests and removes all associated promises.\n  cancelRequests() {\n    this._requestQueue.cancelAll()\n    this.provider._clients && this.provider._clients.disconnect()\n    this.provider.destroy()\n  }\n\n  async _fetch(url: string, options?: RequestOptions): Promise<Response> {\n    const response = await fetch(url, {\n      ...options,\n      headers: (({\n        'X-PSPDFKit-Token': this._state.token,\n        'PSPDFKit-Platform': 'web',\n        'PSPDFKit-Version': `protocol=${PSPDFKIT_DEFINES.SERVER_PROTOCOL}, client=${\n          PSPDFKIT_DEFINES.VERSION\n        }, client-git=${PSPDFKIT_DEFINES.REVISION}`,\n        ...(options && options.headers),\n      }: Object): HeadersInit),\n    })\n\n    if (!response.ok) {\n      const message = (await response.json()).reason || `${response.status} ${response.statusText}`\n\n      throw new PSPDFKitError(message)\n    }\n\n    return response\n  }\n}\n\nasync function createOperationsPayload(operations) {\n  let operationsDocuments = {}\n\n  // If multiple operations use the same blob, we only want to send it once.\n  // We track blobs that have already been appended in a WeakMap(blob => index)\n  let blobWeakMap = new WeakMap()\n\n  const processedOperations = await Promise.all(\n    operations.map(\n      async (operation, index): Promise<DocumentOperationJSON> => {\n        if (operation.type === 'importDocument') {\n          const document = operation.document\n          invariant(\n            document instanceof File || document instanceof Blob,\n            'Wrong `importDocument` operation `document` value: it must be a File or a Blob',\n          )\n          let formIndex\n          // Has this blob been already appended?\n          if (blobWeakMap.has(document)) {\n            // Get the index of the blob\n            formIndex = blobWeakMap.get(document)\n          } else {\n            formIndex = index.toString()\n            // Add the blob to the form payload\n            operationsDocuments[formIndex] = operation.document\n            // Track the blob\n            blobWeakMap.set(document, formIndex)\n          }\n          return {\n            ...operation,\n            document: formIndex,\n          }\n        }\n        return operation\n      },\n    ),\n  )\n\n  let formData = new FormData()\n  formData.append('operations', JSON.stringify(processedOperations))\n  for (let document in operationsDocuments) {\n    formData.append(document, operationsDocuments[document])\n  }\n  return formData\n}\n","/* @flow */\n\nimport { PSPDFKitError } from '@pspdfkit/shared'\nimport { invariant } from '@pspdfkit/shared'\n\n/**\n * This function can be used to validate a JWT. Will throw a PSPDFKitError if\n * the token is invalid.\n * Can also be used to log deprecation warnings.\n */\nexport function validateJWT(jwt: string): void {\n  const JWT_INVALID = `The supplied JWT is invalid. Please refer to our guides on how to set up authentication:\n  https://pspdfkit.com/guides/web/current/server-backed/client-authentication/`\n  const DOCUMENT_ID_NOT_STRING = `The supplied JWT is invalid. The field 'document_id' has to be a string value.\n  Please refer to our guides for further information: https://pspdfkit.com/guides/web/current/server-backed/client-authentication/`\n\n  // Our dashboard uses internal API to authenticate the request. In this case,\n  // the `jwt` is not a valid JWT but another JSON.\n  // We will bypass the validation in this case.\n  if (jwt.indexOf('{\"internal\":') !== -1) {\n    return\n  }\n\n  // We require a JWT to be a string with two dots\n  invariant(typeof jwt === 'string' && jwt.split('.').length === 3, JWT_INVALID)\n\n  // We parse the user data section of the JWT.\n  let userContent\n  try {\n    userContent = JSON.parse(atob(jwt.split('.')[1]))\n  } catch (e) {\n    throw new PSPDFKitError(JWT_INVALID)\n  }\n\n  invariant(typeof userContent.document_id === 'string', DOCUMENT_ID_NOT_STRING)\n}\n"],"sourceRoot":""}