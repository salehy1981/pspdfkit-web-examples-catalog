{"version":3,"sources":["webpack://PSPDFKit/./src/lib/RESTProvider/RESTProviderState.js","webpack://PSPDFKit/./src/lib/RESTProvider/RESTProvider.js"],"names":["RESTProviderState","_ref","classCallCheck_default","this","possibleConstructorReturn_default","getPrototypeOf_default","apply","arguments","inherits_default","Record","alreadyLoadedPages","Map","serverURL","authPayload","isLoaded","isFormsEnabled","loadBookmarksPromise","RESTProvider","state","_initializeFormFieldValues2","_loadBookmarks","_loadAnnotationsForPageIndex","_deleteFormFieldValue","_createFormFieldValue","_setFormFieldValue","_deleteBookmark","_updateBookmark","_createBookmark","_deleteAnnotation","_updateAnnotation","_createAnnotation","_load","createClass_default","key","value","asyncToGenerator_default","regenerator_default","a","mark","_callee","wrap","_context","prev","next","set","_initializeFormFieldValues","abrupt","stop","annotationCallbacks","bookmarkCallbacks","formFieldValueCallbacks","_callee2","annotation","attachments","_serializeAnnotation","id","content","annotationBody","_this","_context2","_verifyLoaded","serializeAnnotation","objectWithoutProperties_default","_request","then","r","status","PSPDFKitError","json","error","newBody","createFormData","_x","_x2","_callee3","_serializeAnnotation2","_context3","concat","_x3","_callee4","annotationId","_context4","_x4","_callee5","bookmark","_serializeBookmark","_context5","loadBookmarks","serializeBookmark","sent","_x5","_callee6","_serializeBookmark2","_context6","_x6","_callee7","bookmarkId","_context7","_x7","_callee8","formFieldValue","payload","_context8","name","serializeFormFieldValue","formFieldValues","_x8","_callee9","_context9","_callee10","_context10","_callee11","pageIndex","payloadPromise","additions","_context11","has","get","response","catch","setIn","Promise","resolve","List","withMutations","mutableAdditions","annotations","map","record","push","deserializeAnnotation","console","info","size","invariant","createAnnotations","ANNOTATION_CREATE_REASON_LOAD","t0","_handleError","_x9","_callee12","bookmarks","_context12","data","Array","isArray","mutableBookmarks","forEach","deserializeBookmark","createBookmarks","BOOKMARK_ANNOTATION_CREATE_REASON_LOAD","_callee13","request","_context13","_ref2","formFieldValueJSON","deserializeFormFieldValue","filter","Boolean","setFormFieldValues","e","type","message","path","method","body","contentTypeHeader","FormData","typeof_default","Content-Type","headers","objectSpread_default","X-PSPDFKit-Token","token","PSPDFKit-Platform","PSPDFKit-Version","PSPDFKIT_DEFINES","fetch","JSON","stringify","undefined","credentials","Error","formData","append","attachment","attachmentId"],"mappings":"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","file":"pspdfkit-lib/chunk-server-rest-cb406c558f95293f.js","sourcesContent":["/* @flow */\n\nimport { Map, Record } from 'immutable'\n\nexport class RESTProviderState extends (Record({\n  alreadyLoadedPages: Map(),\n  serverURL: null,\n  authPayload: null,\n  isLoaded: false,\n  isFormsEnabled: true,\n  loadBookmarksPromise: null,\n}): any) {\n  /**\n   * Used to remember which page annotations have already been loaded.\n   * @member {Immutable.Map.<number, Promise.<void>>} alreadyLoadedPages\n   */\n  alreadyLoadedPages: Map<number, Promise<void>>\n\n  /**\n   * @member {string} serverURL\n   */\n  serverURL: string\n\n  /**\n   * @member {Object} authPayload\n   */\n  authPayload: {\n    token: string,\n  }\n\n  isLoaded: boolean\n\n  isFormsEnabled: boolean\n\n  /**\n   * Used to fire loadBookmarks only once.\n   * @member {?Promise.<void>} loadBookmarksPromise\n   */\n  loadBookmarksPromise: ?Promise<void>\n}\n","/* @flow */\n\nimport {\n  deserializeAnnotation,\n  deserializeFormFieldValue,\n  serializeAnnotation,\n  serializeFormFieldValue,\n} from '../serializers/utils'\nimport {\n  fromJSON as deserializeBookmark,\n  toJSON as serializeBookmark,\n} from '../serializers/BookmarkSerializer'\nimport { CREATE_REASON_LOAD as ANNOTATION_CREATE_REASON_LOAD } from '../AnnotationProvider'\nimport { CREATE_REASON_LOAD as BOOKMARK_ANNOTATION_CREATE_REASON_LOAD } from '../BookmarkProvider'\nimport { invariant } from '@pspdfkit/shared'\nimport { List, Map } from 'immutable'\nimport { PSPDFKitError, error } from '@pspdfkit/shared'\nimport { RESTProviderState } from './RESTProviderState'\nimport type { Annotation, Attachment, Bookmark, FormFieldValue } from '../../models'\nimport type { AnnotationProvider, AnnotationProviderCallbacks } from '../AnnotationProvider'\nimport type { BookmarkProvider, BookmarkProviderCallbacks } from '../BookmarkProvider'\nimport type { FormFieldValueProvider, FormFieldValueCallbacks } from '../FormFieldValueProvider'\nimport type { ID as AnnotationID } from '../../models/annotations/Annotation'\nimport type { ID as BookmarkID } from '../../models/Bookmark'\n\n/**\n * A REST interface to annotation loading. It can't handle real time update and will fetch\n * annotations per-page.\n *\n * @TODO How do we handle errors?\n */\nexport class RESTProvider implements AnnotationProvider, BookmarkProvider, FormFieldValueProvider {\n  annotationCallbacks: ?AnnotationProviderCallbacks\n  bookmarkCallbacks: ?BookmarkProviderCallbacks\n  formFieldValueCallbacks: ?FormFieldValueCallbacks\n  state: RESTProviderState\n\n  constructor(\n    serverURL: string,\n    authPayload: { token: string },\n    { isFormsEnabled }: { isFormsEnabled: boolean },\n  ) {\n    this.state = new RESTProviderState({ serverURL, authPayload, isFormsEnabled })\n  }\n\n  /*************************\n   * Connection management *\n   *************************/\n\n  async load(): Promise<this> {\n    this.state = this.state.set('isLoaded', true)\n\n    if (this.state.isFormsEnabled) {\n      // Form Field Values are not loaded on a per-page basis. Thus, we fetch them all in here\n      await this._initializeFormFieldValues()\n    }\n\n    return this\n  }\n\n  destroy(): void {}\n\n  setAnnotationCallbacks(annotationCallbacks: AnnotationProviderCallbacks) {\n    this.annotationCallbacks = annotationCallbacks\n  }\n\n  setBookmarkCallbacks(bookmarkCallbacks: BookmarkProviderCallbacks) {\n    this.bookmarkCallbacks = bookmarkCallbacks\n  }\n\n  setFormFieldValueCallbacks(formFieldValueCallbacks: FormFieldValueCallbacks) {\n    this.formFieldValueCallbacks = formFieldValueCallbacks\n  }\n\n  /******************\n   * Annotation API *\n   ******************/\n\n  async createAnnotation(\n    annotation: Annotation,\n    attachments: Map<string, Attachment>,\n  ): Promise<void> {\n    this._verifyLoaded()\n\n    // We delete id from content so the server doesn't persist the ID in the content.\n    const { id, ...content } = serializeAnnotation(annotation)\n\n    const annotationBody = { id, content }\n\n    await this._request('/annotations', 'POST', annotationBody).then(r => {\n      if (r.status !== 200) {\n        throw new PSPDFKitError('PSPDFKit Server returned an error, when saving an annotation.')\n      }\n      r.json().then(json => {\n        if (json.error === 'attachment_missing') {\n          // When the attachment is not already stored on the server, we need to attach the\n          // attachments to the request\n          const newBody = createFormData(annotationBody, attachments)\n          return this._request('/annotations', 'POST', newBody).then(r => r.json())\n        }\n        return json\n      })\n    })\n  }\n\n  async updateAnnotation(annotation: Annotation): Promise<void> {\n    this._verifyLoaded()\n\n    // We delete id from content so the server doesn't persist the ID in the content.\n    const { id, ...content } = serializeAnnotation(annotation)\n\n    await this._request(`/annotations/${id}`, 'PUT', { id, content })\n  }\n\n  async deleteAnnotation(annotationId: AnnotationID): Promise<void> {\n    this._verifyLoaded()\n\n    await this._request(`/annotations/${annotationId}`, 'DELETE')\n  }\n\n  /******************\n   * Bookmark API *\n   ******************/\n\n  async createBookmark(bookmark: Bookmark): Promise<void> {\n    this._verifyLoaded()\n    // Make sure bookmarks are loaded.\n    await this.loadBookmarks()\n\n    // We delete id from content so the server doesn't persist the ID in the content.\n    const { id, ...content } = serializeBookmark(bookmark)\n    const response = await this._request('/bookmarks', 'POST', { id, content })\n    if (response.status !== 200) {\n      throw new PSPDFKitError('PSPDFKit Server returned an error, when saving an bookmark.')\n    }\n  }\n\n  async updateBookmark(bookmark: Bookmark): Promise<void> {\n    this._verifyLoaded()\n    // Make sure bookmarks are loaded.\n    await this.loadBookmarks()\n\n    // We delete id from content so the server doesn't persist the ID in the content.\n    const { id, ...content } = serializeBookmark(bookmark)\n\n    await this._request(`/bookmarks/${id}`, 'PUT', { id, content })\n  }\n\n  async deleteBookmark(bookmarkId: BookmarkID): Promise<void> {\n    this._verifyLoaded()\n    // Make sure bookmarks are loaded.\n    await this.loadBookmarks()\n\n    await this._request(`/bookmarks/${bookmarkId}`, 'DELETE')\n  }\n\n  /******************\n   * FormFieldValue API *\n   ******************/\n\n  async setFormFieldValue(formFieldValue: FormFieldValue): Promise<void> {\n    this._verifyLoaded()\n\n    const payload = {\n      id: `form-field-value/${formFieldValue.name}`,\n      content: serializeFormFieldValue(formFieldValue),\n    }\n    await this._request('/form-field-values', 'POST', {\n      formFieldValues: [payload],\n    })\n  }\n\n  // Stub to be implemented when this provider is supported\n  async createFormFieldValue(): Promise<void> {\n    return\n  }\n\n  // Stub to be implemented when this provider is supported\n  async deleteFormFieldValue(): Promise<void> {\n    return\n  }\n\n  async loadAnnotationsForPageIndex(pageIndex: number): Promise<void> {\n    this._verifyLoaded()\n\n    if (this.state.alreadyLoadedPages.has(pageIndex)) {\n      await this.state.alreadyLoadedPages.get(pageIndex)\n      return\n    }\n\n    try {\n      const payloadPromise = this._request(`/page-${pageIndex}-annotations`, 'GET')\n        .then(response => response.json())\n        .catch(error => {\n          throw error\n        })\n      // We save the promise so that if `loadAnnotationsForPageIndex` is called again\n      // before the promise resolves the new calls awaits for the promise as well!\n      this.state = this.state.setIn(['alreadyLoadedPages', pageIndex], payloadPromise)\n\n      const payload = await payloadPromise\n\n      // At this point we don't need a reference to the original promise anymore.\n      this.state = this.state.setIn(['alreadyLoadedPages', pageIndex], Promise.resolve())\n\n      const additions = List().withMutations(mutableAdditions => {\n        payload.annotations.map(record => {\n          try {\n            mutableAdditions.push(deserializeAnnotation(record.id, record.content))\n          } catch (error) {\n            // eslint-disable-next-line no-console\n            console.info(\n              `Skipped creating annotation #${\n                record.id\n              } from payload because an error occurred while deserializing.`,\n              record.content,\n            )\n            console.info(error) // eslint-disable-line no-console\n          }\n        })\n      })\n      if (additions.size > 0) {\n        invariant(this.annotationCallbacks)\n        this.annotationCallbacks.createAnnotations(additions, Map(), ANNOTATION_CREATE_REASON_LOAD)\n      }\n    } catch (error) {\n      this._handleError(error, 'annotations')\n    }\n  }\n\n  async loadBookmarks() {\n    this._verifyLoaded()\n\n    if (this.state.loadBookmarksPromise) {\n      await this.state.loadBookmarksPromise\n      return\n    }\n\n    try {\n      const payloadPromise = this._request('/bookmarks', 'GET')\n        .then(response => response.json())\n        .then(payload => payload.data)\n        .catch(error => {\n          throw error\n        })\n\n      // We save the promise so that if `loadBookmarks` is called again\n      // before the promise resolves the new calls awaits for the promise as well!\n      this.state = this.state.set('loadBookmarksPromise', payloadPromise)\n\n      const payload = await payloadPromise\n\n      // At this point we don't need a reference to the original promise anymore.\n      this.state = this.state.set('loadBookmarksPromise', Promise.resolve())\n\n      invariant(Array.isArray(payload.bookmarks), 'Unexpected reply from bookmarks endpoint.')\n\n      const bookmarks = List().withMutations(mutableBookmarks => {\n        payload.bookmarks.forEach((json: Object) => {\n          try {\n            mutableBookmarks.push(deserializeBookmark(json.id, json.content))\n          } catch (error) {\n            // eslint-disable-next-line no-console\n            console.info(\n              `Skipped creating bookmark #${\n                json.id\n              } from payload because an error occurred while deserializing.`,\n              json,\n            )\n            console.info(error) // eslint-disable-line no-console\n          }\n        })\n      })\n\n      if (bookmarks.size > 0) {\n        invariant(this.bookmarkCallbacks)\n        this.bookmarkCallbacks.createBookmarks(bookmarks, BOOKMARK_ANNOTATION_CREATE_REASON_LOAD)\n      }\n    } catch (error) {\n      this._handleError(error, 'bookmarks')\n    }\n  }\n\n  async _initializeFormFieldValues(): Promise<void> {\n    const request = await this._request('/form-field-values', 'GET')\n    const response = await request.json()\n\n    invariant(\n      Array.isArray(response.formFieldValues),\n      'Unexpected reply from form-values endpoint.',\n    )\n\n    const formFieldValues = List(\n      response.formFieldValues\n        .map(({ content: formFieldValueJSON }) => {\n          try {\n            return deserializeFormFieldValue(formFieldValueJSON)\n          } catch (error) {\n            // eslint-disable-next-line no-console\n            console.info(\n              `Skipped form field value ${\n                formFieldValueJSON.name\n              } from payload because an error occurred while deserializing.`,\n              formFieldValueJSON,\n            )\n            console.info(error) // eslint-disable-line no-console\n            return null\n          }\n        })\n        .filter(Boolean),\n    )\n\n    invariant(this.formFieldValueCallbacks)\n    this.formFieldValueCallbacks.setFormFieldValues(formFieldValues)\n  }\n\n  _handleError(e: Error, type: 'annotations' | 'bookmarks') {\n    error(`Loading or updating ${type} failed:\n\n${e.message}`)\n  }\n\n  _request(\n    path: string,\n    method: 'GET' | 'POST' | 'PUT' | 'DELETE',\n    body?: Object,\n  ): Promise<Object> {\n    invariant(this.state.authPayload != null, 'Cannot call request without authPayload')\n\n    const contentTypeHeader =\n      !(body instanceof FormData) && typeof body === 'object'\n        ? { 'Content-Type': 'application/json' }\n        : null\n\n    const headers = {\n      'X-PSPDFKit-Token': this.state.authPayload.token,\n      'PSPDFKit-Platform': 'web',\n      'PSPDFKit-Version': `protocol=${PSPDFKIT_DEFINES.SERVER_PROTOCOL}, client=${\n        PSPDFKIT_DEFINES.VERSION\n      }, client-git=${PSPDFKIT_DEFINES.REVISION}`,\n      ...contentTypeHeader,\n    }\n\n    return fetch(`${(this.state.serverURL: any)}${path}`, {\n      method,\n      headers,\n      body:\n        body instanceof FormData\n          ? body\n          : typeof body === 'object'\n          ? JSON.stringify(body)\n          : undefined,\n      credentials: 'include',\n    })\n  }\n\n  _verifyLoaded() {\n    if (!this.state.isLoaded) {\n      throw new Error('not loaded')\n    }\n  }\n}\n\nfunction createFormData(annotationBody, attachments) {\n  let formData = new FormData()\n  formData.append('annotation', JSON.stringify(annotationBody))\n  attachments.forEach((attachment, attachmentId) => {\n    if (attachmentId && attachment.data) {\n      formData.append(attachmentId, attachment.data)\n    }\n  })\n\n  return formData\n}\n"],"sourceRoot":""}